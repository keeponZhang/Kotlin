package com.keepon.kotlin.chapter13

/**
 * createBy	 keepon
 */
//变量的类型 规定了 变量的可能值，有时候我们会把类型和类当成同样的概念使用，但它们不一样。

//非泛型类
//对于非泛型类来说，类的名称可以直接当作类型使用。例如，var x : String声明了一个可以保存String类的实例的变量，
//而var x : String?声明了它的可空类型版本，这意味着 一个Kotlin类都可以用于构造至少两种类型。
//
//
//泛型类
//要得到一个合法的类型，需要首先得到一个泛型类，并用一个作为 类型实参的具体类型 替换泛型类的 类型形参。
//List是一个类而不是类型，下面列举出来的所有替代品都是合法的类型：List<Int>、List<String?>和List<List<String>>，每一个 泛型类都可能生成潜在的无限数量的类型。


//子类型
//子类型的含义为：
//任何时候如果需要的是类型A的值，能够使用类型B的值当做A的值，类型B就称为类型A的子类型。
//例如Int是Number的子类型，但Int不是String的子类型，这个定义还表明了任何类型都可以被认为是它自己的子类型。
//
//超类型
//超类型 是 子类型 的反义词
//如果A是B的子类型，那么B就是A的超类型。
//编译器在每一次给变量赋值或者给函数传递实参的时候都要做这项检查：
//只有 值的类型 是 变量类型的子类型 时，才允许存储变量的值
//只有当 表达式的类型 是 函数参数的类型的子类型 时，才允许把该表达式传给函数

//子类、子类型
//在简单情况下，子类和子类型本质上是一样的，例如Int类是Number的子类，因此Int类型是Number类型的子类型。
//一个非空类型是它的可空版本的子类型，但它们都对应着同一个类，你始终能够在可空类型的变量中存储非空类型值。
//
//当开始涉及泛型类时，子类型和子类之间的差异就显得格外重要。正如我们上面见到的，MutableList<String>不是MutableList<Any>的子类型。
//对于泛型类MutableList而言，无论A和B是什么关系，MutableList<A>既不是MutableList<B>的子类型也不是它的超类型，它就被称为 在该类型参数上是不变型的。
//
//Java中的所有类都是不变型的。在前一节中，我们见到了List类，对它来说，子类型化规则不一样，Kotlin中的List接口表示的是只读集合。
//如果A是B的子类型，那么List<A>就是List<B>的子类型，这样的类或者接口被称为 协变的。















