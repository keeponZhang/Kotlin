package com.kotlin.action.ch01.Katlin的设计哲学.kt

/**
 *createBy keepon
 */
//1.4.1 务实
//务实对我们来说意味着一件简单的事情： Ko ti in 就是一门设计出来解决现实世
//界问题的实用语言。它的设计基于多年创建大型系统的工业经验，它的特性也是为
//解决许多软件开发者遇到的场景而选择的。此外，来自JetBrains 内部和社区的开发
//者已经使用Kotlin 的早期版本很多年，他们的反馈也被融合进了这门语言公开发布
//的版本中。所以我们才能自信地说， Koti in 能够帮助解决实际项目的问题。
//Kotlin 也不是一门研究性的语言。我们没有试图提升编程语言设计领域目前的
//技术水平，也没有尝试探索计算机科学的创新理念。反而，我们会尽可能地依赖已
//经出现在其他编程语言中并被证明是成功的那些特性和解决方案。这降低了语言的
//复杂性，也让它更容易学习，因为你可以仰仗那些熟悉的概念。
//此外， Koti in 也没有强制使用某种特定的编程风格和范式。当你开始学习这门
//语言的时候，可以使用熟悉的来自Java 经验的风格。然后，你会渐渐地发现更多强
//大的Kotlin 特性，并学习把它们应用到你的代码中，让代码更简洁、更符合语言习惯。
//Kotlin 的实用主义的另一个重要体现是对于工具的专注。对开发者的生产力而
//言， 一个智能的开发环境和一门设计良好的语言同样重要。因此，事后再来考虑对
//IDE 进行支持就是马后炮。而Kotlin 的情况是， IntelliJ IDEA 的插件是和编译器同
//步开发的， 并且在设计语言特性时始终牢记着对工具的支持。
//IDE 支持对帮助你探索Kotlin 的特性也发挥着重要作用。许多情况下，工具会
//发现那些可以用更简洁的结构来替换的通用代码模式，并给你提供修正这些代码的
//选择。通过研究自动修正所使用的语言特性，你就能学习如何在自己的代码中应用
//这些特性。
//
//1.4.2 简洁
//和编写新代码相比，开发人员会耗费更多的时间来阅读现有代码，这己经是常
//识。想象一下你所在的团队正在开发一个大项目，而你的工作是添加一个新特性或
//者修改bug。第一步会干什么？首先要找到需要改变的那段代码，然后才能实现你
//的修改。要阅读很多代码才能知道你要做什么。这些代码可能最近刚完成，由你的
//同事或者是那些己经离开的同事编写，或者是你自己很久之前写好的。只有搞懂了
//周围的代码你才能做出正确的改动。
//代码越简单越简洁，你就能越快地了解发生了什么。当然，良好的设计和达意
//的命名在这里起着重要的作用。但语言的选择及其简洁性也很重要。如果语言的语
//法清晰地表达了被阅读的代码的意图，没有因为达成意图所需的样板代码而晦涩难
//懂，那么它就是简洁的。
//在Kotlin 中，我们努力地保证你写的代码都具有实际的意义，而不是仅仅为了
//满足代码结构的需要。许多标准的Java 样板代码， 例如getter 、se忧er 以及将构造方
//法的参数赋值给宇段的逻辑，在Koti in 中都是隐式的，并不会使你的源代码变得
//混乱。
//
//另外一个导致代码变得不必要的冗长的原因是编写显式的代码来完成常见的任
//务，比如定位集合中的元素。和许多其他现代语言一样， Ko ti in 有丰富的标准库，
//让你用库方法调用来代替这些冗长重复的代码段。Kotlin 对lambda 的支持，让小代
//码块可以轻松地传递给库函数。这让你可以把公共的那部分代码全部封装在库中，
//而在用户代码中仅保留特定的针对任务的那部分。
//与此同时， Kotlin 并没有尝试把源代码压缩到最小可能的长度。例如，即使
//Kotlin 支持运算符重载，用户也不能定义自己的运算符。因此，库开发者不能用神
//秘的标点符号序列来代替方法名字。单词比标点符号显然更易读，也更容易找到相
//关的文档。
//越简洁的代码写起来花的时间越短，更重要的是，读起来耗费的时间也更短。
//这会提高你的生产力并让你更快地达成目标。


//1.4.3 安全
//通常，我们说一门编程语言是安全的，我们的意思是它的设计可以防止程序出
//现某些类型的错误。当然，这并不意味着绝对的高质量，没有任何语言可以阻止所
//有可能出现的错误。此外，预防错误是需要成本的。需要给编译器提供程序有关预
//期操作更多的信息，这样编译器才能验证这些信息是否和程序的功能匹配。因此，
//你要在得到的安全级别和因为增加更多细节注解而造成的生产力损失之间权衡利
//弊。
//使用Kotlin ，我们试图实现比Java 更高的安全级别，同时保持更低的总体成本。
//在NM 上运行己经提供了许多的安全保证：例如，内存安全，防止了缓冲区溢出
//以及其他错误的动态内存分配造成的问题。作为面向NM 的静态类型语言， Koti in
//还保证了应用程序的类型安全。这比使用Java 的成本要更低：不需要指定所有的类
//型声明，因为许多情况下编译器会自动地推断出类型。
//Kotlin 所做的不止这些，这意味着更多的原本在运行时失败的错误在编
//译期的检查中就被阻止了。最重要的一点是， Kotlin 努力地从你的程序中消除
//NullPointerExceptiono Kotlin 的类型系统跟踪那些可以或不可以为null 的
//值，并且禁止那些运行时可能导致NullPointerException 的操作。这所带来
//的额外的成本是极小的：把类型标记为可空的只要一个字符，就是类型尾部的一个
//问号：
//
//除此之外， Kotlin 提供了许多便利的方法来处理可空数据。这非常有助于消灭
//应用程序的崩溃。
//Ko ti in 有助于避免的另一种异常类型就是ClassCastExceptiono 当你把一
//个对象转换成一种类型，而没有事先检查它是否是正确的类型时，就会发生这个异
//常。在Java 中，开发者常常省略了这类检查，因为必须反复地在检查和其后的转换
//中写明类型名称。另一方面， Kotlin 中的检查和转换被组合成了一次操作： 一旦检
//查过类型，不需要额外的转换就能直接引用属于这个类型的成员。这样，开发者就
//没有借口跳过检查，也不会给错误留下可乘之机。下面展示了它是如何工作的：
//
//
//1.4.4 互操作性
//＋一一检查类型
//「调用该类型
//的方法
//关于互操作性，你的第一个问题可能是：“我是不是可以继续使用现有的
//库？” Kotlin 给出的回答是：“ 当然可以。”无论需要使用哪种库提供的API ，都可
//以在Kotlin 中使用它们。可以调用Java 的方法，继承Java 的类和实现Java 的接口，
//在Kotlin 类上应用Java 的注解，等等。
//与其他一些NM 语言不同， Kotlin 在互操作性上更上一层楼，让Java 代码也
//可以毫不费力地调用Kotlin 的代码。无须取巧： Kotlin 的类和方法可以像常规的
//Java 类和方法一样被调用。这带来了无限的灵活性，在项目的任何地方都可以混合
//使用Java 和Kotlin。当你刚开始在自己的Java 项目中引入Kotlin 时，可以在代码库
//中的任意一个类上运行Java 到Kotlin 的转换器，剩下的代码不需要任何修改就可以
//继续编译和工作。不管你所转换的类是什么角色，这都是可行的。
//另一个Koti in 专注于互操作性的领域是在最大程度上使用现有的Java 库。例如，
//Kotlin 没有自己的集合库，它完全依赖Java 标准库中的类，使用额外的函数来扩展
//它们，让它们在Kotlin 中用起来更方便（我们会在3.3 节中了解这种机制更多的细节）。
//这意味着在Kotlin 中调用JavaAPI 时，永远不需要包装或者转换这些Java 对象，反
//之亦然。所有这些Kotlin 提供的丰富的API 在运行时没有任何的额外开销。
//Kotlin 工具也对跨语言项目提供了全面支持。它可以编译任意混合的Java 和
//Kotlin 源码，不管它们之间是怎样互相依赖的。IDE 的特性也能跨语言工作，允许：
//· 自由地在Java 和Kotlin 源码文件之间切换
//· 调试混合语言的项目，可以在不同语言编写的代码之中单步调试
//· 重构Java 方法的时候， Kotlin 代码中的对它们的调用也会得到正确的更新，反之亦然
//希望我们已经说服你尝试一下Koti in 。现在，你要如何开始使用它？在接下来
//的一节中，我们将从命令行和其他不同工具的使用两方面讨论编译和运行Kotlin 代
//码的过程。









































































